\subsection{Opdracht 05a}

Vermoedelijk zijn niet alle Film ID’s in gebruik. Geef het statement dat de langste aaneengesloten reeks geeft van Film ID’s in jouw database.

\subsubsection{Versie 01}

TODO: Marc

\lstinputlisting[language=SQL]{sql/marc/opdracht-01-05a.sql}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{image/marc/opdracht-05a.PNG}
    \caption{Queryplan Opdracht 05 Versie 01}
\end{figure}

\subsubsection{Versie 02}

TODO: Joey

\lstinputlisting[language=SQL]{sql/joey/opdracht-01-05a.sql}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{image/joey/opdracht-05a.PNG}
    \caption{Queryplan Opdracht 05 Versie 02}
\end{figure}


\subsubsection{Versie 03}
In de eerste CTE worden de rijnummers, en de product\_id weergegven en in de 3e kolom word het verschil tussen deze 2 weergegeven.
Wanneer deze diff verschilt van de vorige diff waarde weet je dat er een gap is.
In de tweede CTE word er eerst gegroepeerd op de diff waarde. Nu hebben we alle islands gegroepeerd.
Vervolgens pakken we de hoogste en laagste waarde van een island, en berekenen we de lengte.
Als laatste stap halen we de hoogste waarde voor lengte er uit, en presenteren we die.

\lstinputlisting[language=SQL]{sql/nick/opdracht-01-05a.sql}
\begin{figure}
    \centering
    \includegraphics[width=1\textwidth]{image/nick/opdracht-05a.PNG}
    \caption{Queryplan Opdracht 05 Versie 02}
\end{figure}


\subsubsection{Conclusie}

\begin{tabular}{ || l | l | l | l | l | l | l | l | l | l | l | l | 1 | 1 | l | 1 | 1 || }
    \hline
    \textbf{Statement} & \textbf{Est Cost \%} & \textbf{Compile Time} & \textbf{Duration} & \textbf{CPU} & \textbf{Est CPU Cost \%} & \textbf{Est IO Cost \%} \\
    \hline
    \hline
    Versie03  & 36,5\%  & 19  & 3.154  & 5.022  & 36,2\% & 40,0\%  \\
    Versie02  & 27,0\%  & 9  & 2.357  & 2.973  & 25,5\% & 20,7\% \\
    Versie01  & 36,5\%  & 10  & 1.848  & 3.215  & 36,2\% & 39,4\%  \\
    \hline
    \hline
    \hline
\end{tabular}
\newline
\newline
\begin{tabular}{ || l | l | l | l | l | l | l | l | l | l | l | l | 1 | 1 | l | 1 | 1 || }
    \hline
    \textbf{Statement} &  \textbf{Est Rows} & \textbf{Actual Rows} & \textbf{RID Lookups} & \textbf{Parallel} & \textbf{Sort} & \textbf{Table Scan} & \textbf{Hash Match} \\
    \hline
    \hline
    Versie03  & 1        & 1  & 0  & 19  & 2  & 2  & 2 \\
    Versie02  & 1        & 1  & 0  & 10  & 2  & 1  & 0 \\
    Versie01  & 388.403  & 1  & 0  & 21  & 2  & 2  & 2 \\
    \hline
    \hline
    \hline
\end{tabular}


Doordat in de index de product\_type niet is meegenomen, zie je dat er Table Scans met een Sort word uitgevoerd op een grote tabel.
Dit brengt de nodige vertraging met zich mee, alleen ontkomen alle 3 versie's hier niet aan.
Maar toch is de performance van versie 02 een stukje beter.

De reden